# CH2. algorithmAnalysis
- 어떤 응용프로그램에서 어느 클래스가 더 좋을지 결정하는 한가지 방법은 둘 다 시도해보고 각각 얼마나 걸리는지 알아보는 것 -> 프로파일링이라 부름 하지만 여기에는 몇 가지 문제점이 있음
  - 알고리즘을 비교하려면 사전에 그것을 모두 구현해봐야 알 수 있다.
  - 결과는 사용하는 컴퓨터의 성능에 의존
  - 결과는 문제 크기나 입력으로 사용하는 데이터에 의존하기도 함
  - 알고리즘 분석을 사용하여 이러한 문제점을 해결 가능!

## 하지만 이를 위해서는 몇 가지 가정을 해야만 함
- 컴퓨터 하드웨어의 세부사항을 다루지 않기 위해 보통 알고리즘을 이루는 더하기와 곱하기, 숫자 비교등의 기본연산을 식별. 그리고 각 알고리즘에 필요한 연산 수를 셉니다.
- 입력 데이터의 세부사항을 다루지 않으려면 가장 좋은 선택은 기대하는 입렫 데이터에 대한 평균 성능을 분석하는 것 -> 이것이 가능하지 않을 때는 일반적인 대안으로 최악의 시나리오를 분석하기도함
- 한 알고리즘이 작은 문제 -> 최상의 성능 , 하지만 큰 문제에서는 다른 알고리즘이 더 좋을 수 있음 이 때는 보통 큰 문제에 초점을 맞추기

## 알고리즘은 다음 몇가지 범주로 나뉩니다.
### 상수 시간 (입력 크기에 관계없이)
- 실행시간이 입력 크기에 의존하지 않으면 알고리즘은 상수시간을 따른다고 합니다.
- 예를들어 n개의 배열에서 [브래킷 연산](WIKI.md#bracket-operation)을 사용하여 요소 중 하나에 접근할 때 이 연산은 배열의 크기와 관계없이 같은 수의 동작을 수행
```Java
public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int firstElement = arr[0];  // 이 작업은 상수시간!
        System.out.println("첫 번째 요소: " + firstElement);
    }
}

public class Main {
    public static void main(String[] args) {
        int a = 5;
        int b = 3;
        int sum = a + b;  // 이 작업도 상수시간!
        System.out.println("두 수의 합: " + sum);
    }
}

public class Main {
    public static void main(String[] args) {
        int x = 10;  // 이 작업도 상수시간!
        System.out.println("변수 x의 값: " + x);
    }
}
```
---------------------------------------
- 알고리즘의 복잡도를 분석할 때, 상수시간 작업은 O(1)으로 표현
- O(1)은 입력 크기에 관계없이 일정한 시간이 걸린다는 의미.
### 선형 (입력 크기에 비례)
- 실행시간이 입력의 크기에 비례하면 알고리즘은 선형이라고 함
- 예를들어 배열에 있는 요소를 더한다면 n개 요소에 접근하여 n-1 번 더하기 연산을 해야함 . 연산(요소 접근과 더하기) 의 총 횟수는 2n-1 이고 n에 비례
```Java
public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        System.out.println("배열의 모든 요소 합: " + sum);
    }
}
// for 루프는 배열의 크기(arr.length)만큼 반복됨. 따라서 배열의 크기가 커질수록
// sum += arr[i] 작업이 더 많이 수행되고, 전체 작업 시간도 배열의 크기에 비례하게 늘어남
```
- 선형 시간 작업은 O(n)으로 표현
- n은 입력의 크기를 나타냄. O(n)은 입력 크기에 비례하는 시간이 걸린다는 의미
---------------------------------------
### 이차
- 실행시간이 n^2에 비례하면 알고리즘은 이차라고 함
- 예를들어 리스트에 있는 어떤요소가 두번 이상 나타나는지 알고 싶다고 가정. 간단한 알고리즘은 각 요소를 다른 모든 요소와 비교하는 것 
- n개의 요소가 있고 각각 n-1 번 비교하면 총 비교횟수는 n^2-n 이 되어 n이 커지면서 n^2에 비례
```Java
public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++) {
                System.out.println("비교: " + arr[i] + "와 " + arr[j]);
            }
        }
    }
}
```
- for 루프 두번 중첩 -> arr.length * arr.length 번 반복 -> 이는 입력크기의 제곱에 비례
- 버블정렬도 마찬가지
- 이차 시간 작업은 O(n^2)으로 표현


